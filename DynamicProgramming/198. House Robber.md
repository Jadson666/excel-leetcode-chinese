# 題目
https://leetcode.com/problems/house-robber/description/

# 開始分析
- 本題目背後的核心概念
  - 可否拆解成子問題？是，其實就兩種情況搶、不搶。搶的話除了前一個間不能搶是確定的，其餘都可以拆宅成子問題推演。若是不搶的話，就沒有可以確定的，也就是剩餘的繼續拆成子問題
- 如何從問題推導出使用的解題工具
  - 動態回歸四定義
- 如何推導出最優複雜度
  - 遍歷一遍 -> O(n)
  - 儲存 dp[0~n] 的贓款數量 -> O(n)

### 動態回歸
##### 如何解釋解題思路
分解子問題的思路是都把確定不能搶的移除掉，剩下的子問題都能暫時「不受限制」的繼續分割，以[1,2,3,4]為例，假設我們正在決定尾端的房間搶不搶可以分為以下情況：
1. 搶：要搶4的話確定3不能搶，所以剩下子問題[1,2], [4]  <-- [4] 等於4，因為剩下一間就一定是搶
2. 不搶：確定4不搶的話，剩下的子問題是[1,2,3]

是不是稍微理解爲什麼要「不受限制」才能切子問題了？因為[1,2,3]如果還要考慮3的下一間有沒有被搶，那就不是子問題。以上兩種情況取最多贓款的情況，寫成遞迴幫助理解下：

```js
const rob = (i) => {
  return Math.max(rob(i-2) + nums[i], rob(i-1))
}
```
我們直接動態規劃四定義：
1. 定義 dp[i] = x ，意即遵守規則搶劫房子0~i，所能搶到最多金錢為 x
2. 狀態轉移邏輯：搶與不搶取大的，dp[i] = max(dp[i-1], dp[i-2] + nums[i])
3. 初始化：先把 dp[0] = nums[0]，dp[1] = max(nums[0], nums[1]) 作為基礎值
4. 遍歷順序由左至右
##### 經分析後，本題詳細步驟如下：
1. 總共n個數字，創建dp[n-1]並且初始化dp[0]、dp[1]
2. 遍歷所有數字，dp[i]等於搶、不搶的總額中取最高的
3. 遍歷完成，dp[n-1]即為答案

時間複雜度：O(n)  
空間複雜度：O(n)

#### 程式碼
- Javascript
```js
var rob = function (nums) {
    if (nums.length === 1) return nums[0]
    const dp = Array(nums.length).fill(0)
    dp[0] = nums[0]
    dp[1] = Math.max(nums[1], nums[0])
    for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(nums[i] + dp[i-2], dp[i-1])
    }
    return dp.at(-1)
};
```
